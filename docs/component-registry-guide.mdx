# 📚 Interactive Component Registry - Shadcn/UI CLI Distribution

## 🎯 Overview

This guide provides comprehensive documentation for our professional component distribution system using the shadcn/ui CLI approach. Our registry enables components to be installed via CLI commands rather than file copying, following modern component distribution patterns.

## 🏗️ Architecture Overview - Shadcn/UI CLI System

```
myApp/
├── app-x/                    # Registry Provider (Shadcn/UI Registry)
│   ├── registry.json         # Component registry schema
│   ├── registry/             # Registry directory structure
│   │   └── components/
│   │       └── interactive-table/
│   │           ├── interactive-table.tsx    # Self-contained component
│   │           └── interactive-table.json   # Component metadata
│   ├── public/
│   │   └── r/                # Served registry files
│   ├── src/
│   │   └── components/       # Development versions
│   └── package.json
├── app-y/                    # CLI Consumer (Enhanced)
│   ├── components.json       # Shadcn CLI configuration
│   ├── src/
│   │   ├── components/
│   │   │   └── ui/           # CLI-installed components
│   │   ├── hooks/
│   │   │   └── useJikanAPI.ts       # Custom hooks
│   │   └── App-enhanced.tsx
│   └── package.json
├── app-z/                    # Component Consumer (Tailwind Integration)
│   ├── src/
│   │   ├── components/
│   │   │   └── interactive-table/   # Copied from app-x
│   │   └── App.tsx
│   ├── tailwind.config.js
│   ├── postcss.config.js
│   └── package.json
└── docs/
    └── component-registry-guide.mdx  # This document

### Quick Start Scripts

The project includes a unified startup script for easy development:

```bash
# From myApp root directory

# Start default apps (app-x + app-y)
./start.sh

# Start all three apps
./start.sh x,y,z

# Start only app-z (Tailwind integration)
./start.sh z

# Start app-x and app-z
./start.sh x,z
```

**Available Applications:**
- **app-x** (port 5173): Component Registry Provider - Basic implementation
- **app-y** (port 5174): Enhanced Consumer - API integration, pagination, infinite scroll
- **app-z** (port 5175): Tailwind CSS Integration - Demonstrates CSS framework integration

### Path Context

**Important:** All paths in this documentation are relative to the `myApp` directory unless otherwise specified:

```bash
myApp/              # 👈 Root context for all relative paths
├── app-x/          # Registry provider
├── app-y/          # Enhanced consumer
├── app-z/          # Tailwind integration
├── docs/           # This documentation
└── start.sh        # Unified startup script
```

When working **inside** the myApp project:
- Use relative paths: `app-x/src/components/`
- Scripts assume you're in myApp root: `./start.sh`

When working **outside** the myApp project (new applications):
- Use absolute paths: `/path/to/myApp/app-x/src/components/`
- Reference the full path to copy components
```

---

## 🔧 Component Creation & Registry Management

### 1. Creating Components in the Registry (App X)

#### Step 1: Define Component Types

Create comprehensive TypeScript interfaces in `src/components/interactive-table/types.ts`:

```typescript
import type { ReactNode } from 'react';

/**
 * Definition of a column for the interactive table
 */
export interface ColumnDef<T> {
  /** Data object key to access the value */
  accessorKey: keyof T;
  /** Column header text */
  header: string;
  /** Indicates if the column is editable */
  isEditable?: boolean;
  /** Callback function when a cell is updated */
  onCellUpdate?: (rowId: string | number, newValue: string | number) => void;
  /** Custom function to render cell content */
  cell?: (value: string | number | boolean, rowData: T) => ReactNode;
}

/**
 * Props for the InteractiveTable component
 */
export interface InteractiveTableProps<T> {
  /** Array of data to display in the table */
  data: T[];
  /** Column definitions */
  columns: ColumnDef<T>[];
  /** Callback function when a complete row is updated */
  onRowUpdate?: (updatedRow: T) => void;
  /** Unique key to identify each row */
  rowKey?: keyof T;
}

/**
 * Props for an editable cell
 */
export interface EditableCellProps<T> {
  value: string | number | boolean;
  rowData: T;
  column: ColumnDef<T>;
  rowId: string | number;
}
```

#### Step 2: Create Base UI Components

Create reusable UI components in `src/components/ui/`:

```typescript
// src/components/ui/table-basic.tsx
import React from 'react';

export const Table = React.forwardRef<HTMLTableElement, TableProps>(
  ({ className = '', children, ...props }, ref) => (
    <div style={{ width: '100%', overflowX: 'auto' }}>
      <table
        ref={ref}
        style={{
          width: '100%',
          borderCollapse: 'collapse',
          fontSize: '0.875rem'
        }}
        {...props}
      >
        {children}
      </table>
    </div>
  )
);

// Additional table components: TableHeader, TableBody, TableRow, etc.
```

#### Step 3: Create Core Components

Build the main interactive components:

```typescript
// src/components/interactive-table/InteractiveTable-basic.tsx
export function InteractiveTable<T>({
  data,
  columns,
  rowKey = 'id' as keyof T,
}: InteractiveTableProps<T>) {
  // Implementation with generic TypeScript support
  // Handles rendering, editing, and implicit saving
}
```

```typescript
// src/components/interactive-table/EditableCell-basic.tsx
export function EditableCell<T>({
  value: initialValue,
  column,
  rowId,
}: EditableCellProps<T>) {
  // Implementation with onBlur implicit saving
  // Handles focus states and value updates
}
```

### 2. Updating Components in the Registry

#### Version Control Best Practices

1. **Semantic Versioning**: Use meaningful version numbers
2. **Backward Compatibility**: Ensure existing consumers don't break
3. **Migration Guides**: Document breaking changes

#### Update Process

```bash
# 1. Create feature branch
git checkout -b feature/table-enhancement

# 2. Update component
# Make changes to InteractiveTable-basic.tsx

# 3. Update types if needed
# Modify types.ts for new features

# 4. Test in App X
cd app-x
npm run dev

# 5. Update version and changelog
# Update package.json version
# Document changes in CHANGELOG.md

# 6. Commit and merge
git commit -m "feat: add new column sorting feature"
git push origin feature/table-enhancement
```

### 3. Exporting Components from Registry

#### Create Export Index

```typescript
// src/components/index.ts
export { InteractiveTable } from './interactive-table/InteractiveTable-basic';
export { EditableCell } from './interactive-table/EditableCell-basic';
export type {
  ColumnDef,
  InteractiveTableProps,
  EditableCellProps
} from './interactive-table/types';

// UI Components
export { Table, TableHeader, TableBody, TableRow, TableHead, TableCell } from './ui/table-basic';
export { Input } from './ui/input-basic';
```

#### Package Configuration

```json
// package.json
{
  "name": "@myapp/component-registry",
  "version": "1.0.0",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "exports": {
    ".": {
      "import": "./dist/index.js",
      "require": "./dist/index.cjs",
      "types": "./dist/index.d.ts"
    },
    "./styles": "./dist/styles.css"
  },
  "files": [
    "dist",
    "src"
  ]
}
```

---

## 📦 Using Components in Consumer Applications

### Method 1: Direct File Copying (Current Approach)

#### For Applications WITHOUT Tailwind CSS

**Step 1: Copy Required Files**

```bash
# Create directory structure
mkdir -p src/components/interactive-table
mkdir -p src/components/ui

# Copy core components (from myApp root)
cp app-x/src/components/interactive-table/* src/components/interactive-table/
cp app-x/src/components/ui/* src/components/ui/
```

**Step 2: Install Dependencies**

```json
// package.json
{
  "dependencies": {
    "react": "^19.1.1",
    "react-dom": "^19.1.1"
  }
}
```

**Step 3: Use Components**

```typescript
// src/App.tsx
import { useState } from 'react';
import { InteractiveTable } from './components/interactive-table/InteractiveTable';
import type { ColumnDef } from './components/interactive-table/types';

interface Product {
  id: number;
  name: string;
  price: number;
  stock: number;
}

function App() {
  const [products, setProducts] = useState<Product[]>([]);

  const columns: ColumnDef<Product>[] = [
    { accessorKey: 'id', header: 'ID' },
    {
      accessorKey: 'name',
      header: 'Product Name',
      isEditable: true,
      onCellUpdate: (rowId, newValue) => {
        setProducts(prev =>
          prev.map(p => p.id === rowId ? { ...p, name: String(newValue) } : p)
        );
      }
    },
    // More columns...
  ];

  return (
    <div>
      <h1>My Application</h1>
      <InteractiveTable data={products} columns={columns} />
    </div>
  );
}
```

#### For Applications WITH Tailwind CSS

**Step 1: Install Tailwind CSS**

```bash
# Install Tailwind CSS and dependencies
npm install -D tailwindcss postcss autoprefixer @tailwindcss/postcss

# Create configuration files manually or via:
# npx tailwindcss init -p
```

**Step 2: Configure Tailwind**

```javascript
// tailwind.config.js
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
    // 👇 Include shared components from app-x (relative from myApp root)
    "app-x/src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}
```

```javascript
// postcss.config.js
export default {
  plugins: {
    '@tailwindcss/postcss': {},
    autoprefixer: {},
  },
}
```

**Step 3: Update CSS**

```css
/* src/index.css */
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Your custom styles can still be added here */
.custom-table {
  @apply border border-gray-200 rounded-lg;
}
```

**Step 4: Copy and Adapt Components**

```bash
# Copy components (same as without Tailwind, from myApp root)
cp -r app-x/src/components ./src/

# Optionally, create Tailwind-specific variants
cp src/components/interactive-table/InteractiveTable-basic.tsx \
   src/components/interactive-table/InteractiveTable-tailwind.tsx
```

**Step 5: Use with Tailwind Classes (Optional)**

```typescript
// src/App.tsx - Using Tailwind classes
function App() {
  return (
    <div className="min-h-screen bg-gray-50 p-8">
      <div className="max-w-6xl mx-auto">
        <header className="mb-8 text-center">
          <h1 className="text-3xl font-bold text-gray-900 mb-2">
            My Application with Tailwind
          </h1>
          <p className="text-gray-600">
            Using shared components with Tailwind CSS
          </p>
        </header>

        <div className="bg-white rounded-lg shadow-sm border p-6">
          <InteractiveTable
            data={products}
            columns={columns}
          />
        </div>
      </div>
    </div>
  );
}
```

### Method 2: NPM Package Distribution (Future Enhancement)

#### Creating Publishable Package

```bash
# In app-x directory
npm run build
npm publish --access public

# In consumer app
npm install @myapp/component-registry
```

#### Usage

```typescript
// Consumer application
import {
  InteractiveTable,
  type ColumnDef
} from '@myapp/component-registry';
import '@myapp/component-registry/styles';
```

---

## 🚀 Extending Components

### 1. Creating Extended Components

Build upon the base components for specific use cases:

```typescript
// src/components/PaginatedTable.tsx
import { InteractiveTable } from './interactive-table/InteractiveTable';
import { Pagination } from './Pagination';

interface PaginatedTableProps<T> extends InteractiveTableProps<T> {
  totalPages: number;
  currentPage: number;
  onPageChange: (page: number) => void;
}

export function PaginatedTable<T>({
  totalPages,
  currentPage,
  onPageChange,
  ...tableProps
}: PaginatedTableProps<T>) {
  return (
    <div>
      <InteractiveTable {...tableProps} />
      <Pagination
        currentPage={currentPage}
        totalPages={totalPages}
        onPageChange={onPageChange}
      />
    </div>
  );
}
```

### 2. Custom Hooks for Data Management

```typescript
// src/hooks/useTableData.ts
import { useState, useCallback } from 'react';

export function useTableData<T>(initialData: T[]) {
  const [data, setData] = useState<T[]>(initialData);

  const updateItem = useCallback((id: string | number, updates: Partial<T>) => {
    setData(prev =>
      prev.map(item =>
        (item as any).id === id ? { ...item, ...updates } : item
      )
    );
  }, []);

  const addItem = useCallback((newItem: T) => {
    setData(prev => [...prev, newItem]);
  }, []);

  const removeItem = useCallback((id: string | number) => {
    setData(prev => prev.filter(item => (item as any).id !== id));
  }, []);

  return {
    data,
    updateItem,
    addItem,
    removeItem,
    setData
  };
}
```

### 3. API Integration Patterns

```typescript
// src/hooks/useApiTable.ts
import { useState, useEffect } from 'react';

interface ApiTableHook<T> {
  data: T[];
  loading: boolean;
  error: string | null;
  refresh: () => void;
  updateItem: (id: string | number, updates: Partial<T>) => Promise<void>;
}

export function useApiTable<T>(
  endpoint: string,
  mapResponse: (response: any) => T[]
): ApiTableHook<T> {
  const [data, setData] = useState<T[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchData = async () => {
    try {
      setLoading(true);
      const response = await fetch(endpoint);
      if (!response.ok) throw new Error(`HTTP ${response.status}`);
      const result = await response.json();
      setData(mapResponse(result));
      setError(null);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Unknown error');
    } finally {
      setLoading(false);
    }
  };

  const updateItem = async (id: string | number, updates: Partial<T>) => {
    try {
      const response = await fetch(`${endpoint}/${id}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(updates)
      });

      if (!response.ok) throw new Error(`HTTP ${response.status}`);

      // Optimistic update
      setData(prev =>
        prev.map(item =>
          (item as any).id === id ? { ...item, ...updates } : item
        )
      );
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Update failed');
      // Revert on error
      await fetchData();
    }
  };

  useEffect(() => {
    fetchData();
  }, [endpoint]);

  return {
    data,
    loading,
    error,
    refresh: fetchData,
    updateItem
  };
}
```

---

## 🔄 Integration Workflows

### Workflow 1: New Application Setup (No Tailwind)

```bash
# 1. Create new React application (outside myApp directory)
cd /path/to/your/projects
npm create vite@latest my-new-app -- --template react-ts
cd my-new-app
npm install

# 2. Copy components from registry (from myApp root)
mkdir -p src/components
cp -r /path/to/myApp/app-x/src/components/* src/components/

# 3. Install any additional dependencies
npm install # (usually none needed for basic components)

# 4. Import and use
# Edit src/App.tsx to import and use InteractiveTable

# 5. Start development
npm run dev
```

### Workflow 2: New Application Setup (With Tailwind)

```bash
# 1. Create new React application (outside myApp directory)
cd /path/to/your/projects
npm create vite@latest my-tailwind-app -- --template react-ts
cd my-tailwind-app
npm install

# 2. Install Tailwind CSS
npm install -D tailwindcss postcss autoprefixer @tailwindcss/postcss

# 3. Configure Tailwind
# Create tailwind.config.js and postcss.config.js
# Update src/index.css with @tailwind directives

# 4. Copy components from registry (from myApp root)
mkdir -p src/components
cp -r /path/to/myApp/app-x/src/components/* src/components/

# 5. Update Tailwind config to include component paths
# Edit tailwind.config.js content array

# 6. Import and use with optional Tailwind styling
# Edit src/App.tsx

# 7. Start development
npm run dev
```

### Workflow 3: Existing Application Integration

```bash
# 1. Assessment (from your existing app directory)
# - Does the app use Tailwind CSS?
# - What's the current component structure?
# - Are there conflicts with existing components?

# 2. Prepare integration
# - Backup existing code
# - Plan component placement
# - Identify potential naming conflicts

# 3. Copy components with namespace if needed (from myApp root)
mkdir -p src/components/registry
cp -r /path/to/myApp/app-x/src/components/* src/components/registry/

# 4. Update imports to use new namespace
# import { InteractiveTable } from './components/registry/interactive-table/InteractiveTable';

# 5. Test integration
# - Verify no styling conflicts
# - Test functionality
# - Check TypeScript compilation

# 6. Gradual rollout
# - Replace existing tables one by one
# - Monitor for issues
# - Update documentation
```

---

## 🎨 Styling Integration Strategies

### Strategy 1: CSS-in-JS / Inline Styles (Current)

**Pros:**
- ✅ No external dependencies
- ✅ Self-contained components
- ✅ No style conflicts
- ✅ Works in any environment

**Cons:**
- ❌ Limited design system integration
- ❌ Harder to maintain consistent themes
- ❌ Performance considerations for many components

**Use When:**
- Quick prototyping
- Simple applications
- No design system requirements

### Strategy 2: Tailwind CSS Integration

**Pros:**
- ✅ Utility-first approach
- ✅ Consistent design system
- ✅ Easy responsive design
- ✅ Excellent developer experience

**Cons:**
- ❌ Additional dependency
- ❌ Configuration complexity
- ❌ Potential bundle size increase

**Use When:**
- Modern applications
- Design system requirements
- Team familiar with Tailwind

### Strategy 3: Hybrid Approach

**Pros:**
- ✅ Best of both worlds
- ✅ Gradual migration path
- ✅ Flexibility

**Implementation:**

```typescript
// Component with style prop support
interface TableProps {
  data: any[];
  columns: ColumnDef<any>[];
  className?: string;
  styles?: {
    table?: React.CSSProperties;
    header?: React.CSSProperties;
    cell?: React.CSSProperties;
  };
}

export function InteractiveTable({
  data,
  columns,
  className = '',
  styles = {}
}: TableProps) {
  return (
    <div className={className}>
      <table style={styles.table}>
        {/* Implementation */}
      </table>
    </div>
  );
}
```

---

## 📝 Best Practices & Conventions

### Component Development

1. **Generic TypeScript**: Always use generic types for maximum reusability
2. **Props Interface**: Define clear, documented interfaces
3. **Default Values**: Provide sensible defaults for optional props
4. **Error Handling**: Implement proper error boundaries and validation
5. **Performance**: Use React.memo and useCallback appropriately

### File Organization

```
src/
├── components/
│   ├── interactive-table/
│   │   ├── InteractiveTable.tsx     # Main component
│   │   ├── EditableCell.tsx         # Sub-component
│   │   ├── types.ts                 # TypeScript definitions
│   │   ├── index.ts                 # Barrel export
│   │   └── README.md                # Component documentation
│   └── ui/
│       ├── table.tsx                # Base table components
│       ├── input.tsx                # Base input components
│       └── index.ts                 # Barrel export
├── hooks/
│   ├── useTableData.ts              # Table-specific hooks
│   └── index.ts                     # Barrel export
└── types/
    ├── global.ts                    # Global type definitions
    └── index.ts                     # Barrel export
```

### Documentation Standards

1. **JSDoc Comments**: Document all public APIs
2. **README Files**: Component-level documentation
3. **Example Usage**: Include practical examples
4. **Migration Guides**: Document breaking changes
5. **TypeScript**: Full type coverage

### Testing Strategy

```typescript
// Component.test.tsx
import { render, screen, fireEvent } from '@testing-library/react';
import { InteractiveTable } from './InteractiveTable';

describe('InteractiveTable', () => {
  const mockData = [
    { id: 1, name: 'Test Product', price: 100 }
  ];

  const mockColumns = [
    { accessorKey: 'name', header: 'Name', isEditable: true }
  ];

  it('renders table with data', () => {
    render(<InteractiveTable data={mockData} columns={mockColumns} />);
    expect(screen.getByText('Test Product')).toBeInTheDocument();
  });

  it('handles cell editing', () => {
    const onUpdate = jest.fn();
    const columns = [
      { ...mockColumns[0], onCellUpdate: onUpdate }
    ];

    render(<InteractiveTable data={mockData} columns={columns} />);

    const input = screen.getByDisplayValue('Test Product');
    fireEvent.change(input, { target: { value: 'Updated Product' } });
    fireEvent.blur(input);

    expect(onUpdate).toHaveBeenCalledWith(1, 'Updated Product');
  });
});
```

---

## 🚨 Troubleshooting Guide

### Common Issues

#### 1. TypeScript Errors

**Problem**: "Cannot find module" errors
**Solution**:
```bash
# Ensure all type files are copied (from myApp root)
cp -r app-x/src/types ./src/
# Check tsconfig.json paths configuration
```

#### 2. Styling Conflicts

**Problem**: Components look different than expected
**Solutions**:
- Check for CSS conflicts with existing styles
- Verify Tailwind configuration includes component paths
- Use CSS specificity or CSS modules for isolation

#### 3. Tailwind Not Working

**Problem**: Tailwind classes not applying
**Solutions**:
```bash
# Verify installation
npm list tailwindcss @tailwindcss/postcss

# Check configuration
cat tailwind.config.js
cat postcss.config.js

# Ensure CSS imports are correct
grep -n "@tailwind" src/index.css
```

#### 4. Component Not Rendering

**Problem**: Component renders but appears broken
**Solutions**:
- Check React/ReactDOM versions compatibility
- Verify all dependencies are installed
- Check browser console for errors

### Performance Issues

#### 1. Slow Rendering

**Solutions**:
- Use React.memo for table rows
- Implement virtualization for large datasets
- Optimize re-renders with useCallback

#### 2. Bundle Size

**Solutions**:
- Use tree-shaking with proper exports
- Lazy load components when possible
- Analyze bundle with webpack-bundle-analyzer

---

## 🔄 Migration & Updates

### Updating Components from Registry

```bash
# 1. Check current version
git log --oneline src/components/

# 2. Backup current implementation
cp -r src/components src/components.backup

# 3. Copy updated components (from myApp root)
cp -r app-x/src/components/* src/components/

# 4. Review changes
git diff src/components/

# 5. Test thoroughly
npm run test
npm run build

# 6. Update component usage if needed
# Check for breaking changes in CHANGELOG.md
```

### Version Compatibility Matrix

| Registry Version | React Version | TypeScript | Tailwind CSS |
|-----------------|---------------|------------|--------------|
| 1.0.x           | 18.x - 19.x   | 4.x - 5.x  | Optional     |
| 1.1.x           | 18.x - 19.x   | 5.x+       | 3.x - 4.x    |
| 2.0.x           | 19.x+         | 5.x+       | 4.x+         |

---

## 📋 Checklist Templates

### New Component Integration Checklist

- [ ] Requirements analysis completed
- [ ] Tailwind CSS decision made (yes/no)
- [ ] Directory structure created
- [ ] Components copied from registry
- [ ] Dependencies installed
- [ ] Configuration files updated
- [ ] TypeScript compilation successful
- [ ] Components imported correctly
- [ ] Basic functionality tested
- [ ] Styling verified
- [ ] Error handling tested
- [ ] Performance checked
- [ ] Documentation updated
- [ ] Team review completed

### Component Update Checklist

- [ ] Current version documented
- [ ] Backup created
- [ ] New components copied
- [ ] Breaking changes reviewed
- [ ] TypeScript errors resolved
- [ ] Tests updated
- [ ] Functionality verified
- [ ] Performance regression tested
- [ ] Documentation updated
- [ ] Deployment pipeline updated

---

## 🎯 Future Enhancements

### Planned Features

1. **NPM Package Distribution**
   - Automated publishing pipeline
   - Semantic versioning
   - Proper dependency management

2. **Component Variants**
   - Dark mode support
   - Size variants (sm, md, lg)
   - Theme customization

3. **Advanced Features**
   - Column sorting
   - Filtering capabilities
   - Row selection
   - Drag and drop reordering

4. **Developer Experience**
   - Storybook integration
   - Live documentation
   - Component playground
   - Visual regression testing

### Contributing Guidelines

1. **Code Standards**: Follow existing patterns
2. **Testing**: Maintain 80%+ test coverage
3. **Documentation**: Update docs for all changes
4. **Performance**: No regressions allowed
5. **Accessibility**: WCAG 2.1 AA compliance

---

## 📞 Support & Resources

### Getting Help

1. **Documentation**: Start with this guide
2. **Examples**: Check app-x, app-y, app-z implementations
3. **Issues**: Create GitHub issues for bugs
4. **Discussions**: Use GitHub discussions for questions

### Additional Resources

- [React Documentation](https://react.dev)
- [TypeScript Handbook](https://www.typescriptlang.org/docs/)
- [Tailwind CSS Documentation](https://tailwindcss.com/docs)
- [Vite Guide](https://vite.dev/guide/)

### Contact Information

- **Maintainer**: Component Registry Team
- **Repository**: `github.com/myorg/component-registry`
- **Email**: `components@myorg.com`
- **Slack**: `#component-registry`

---

*Last updated: September 1, 2025*
*Version: 1.0.0*
